{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport path from 'path';\nimport qs from 'query-string';\n\nvar Api = function () {\n  function Api(_ref) {\n    var baseUrl = _ref.baseUrl,\n        searchParams = _ref.searchParams;\n\n    _classCallCheck(this, Api);\n\n    this._baseUrl = baseUrl;\n    this._baseSearchParams = searchParams || {};\n  }\n\n  _createClass(Api, [{\n    key: \"get\",\n    value: function get(endpoint, params) {\n      var hitUrl, response;\n      return _regeneratorRuntime.async(function get$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              hitUrl = this._generateUrl(endpoint, params);\n              _context.next = 3;\n              return _regeneratorRuntime.awrap(fetch(hitUrl, {\n                method: 'GET'\n              }));\n\n            case 3:\n              response = _context.sent;\n              return _context.abrupt(\"return\", this._parseJsonResponse(response));\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"_parseJsonResponse\",\n    value: function _parseJsonResponse(response) {\n      var json, error;\n      return _regeneratorRuntime.async(function _parseJsonResponse$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              json = null;\n              _context2.prev = 1;\n              _context2.next = 4;\n              return _regeneratorRuntime.awrap(response.json());\n\n            case 4:\n              json = _context2.sent;\n              _context2.next = 9;\n              break;\n\n            case 7:\n              _context2.prev = 7;\n              _context2.t0 = _context2[\"catch\"](1);\n\n            case 9:\n              if (!response.ok) {\n                _context2.next = 13;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", json);\n\n            case 13:\n              error = new Error(response.statusText);\n              error.isFromServer = true;\n              error.response = response;\n              error.responseJson = json;\n              throw error;\n\n            case 18:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, [[1, 7]], Promise);\n    }\n  }, {\n    key: \"_generateUrl\",\n    value: function _generateUrl(endpoint, params) {\n      var search = qs.stringify(_objectSpread(_objectSpread({}, this._baseSearchParams), params));\n      var url = path.join(this._baseUrl, endpoint);\n      return [url, search].join('?');\n    }\n  }]);\n\n  return Api;\n}();\n\nexport default Api;","map":{"version":3,"sources":["C:/Users/Nguyen/Desktop/GitHub/netflix_clone/utils/api.js"],"names":["path","qs","Api","baseUrl","searchParams","_baseUrl","_baseSearchParams","endpoint","params","hitUrl","_generateUrl","fetch","method","response","_parseJsonResponse","json","ok","error","Error","statusText","isFromServer","responseJson","search","stringify","url","join"],"mappings":";;;;;;;;;AAAA,OAAOA,IAAP,MAAiB,MAAjB;AACA,OAAOC,EAAP,MAAe,cAAf;;IAGMC,G;AACJ,qBAAuC;AAAA,QAAzBC,OAAyB,QAAzBA,OAAyB;AAAA,QAAhBC,YAAgB,QAAhBA,YAAgB;;AAAA;;AACrC,SAAKC,QAAL,GAAgBF,OAAhB;AACA,SAAKG,iBAAL,GAAyBF,YAAY,IAAI,EAAzC;AACD;;;;WAED,aAAUG,QAAV,EAAoBC,MAApB;AAAA;AAAA;AAAA;AAAA;AAAA;AACQC,cAAAA,MADR,GACiB,KAAKC,YAAL,CAAkBH,QAAlB,EAA4BC,MAA5B,CADjB;AAAA;AAAA,+CAEyBG,KAAK,CAACF,MAAD,EAAS;AACnCG,gBAAAA,MAAM,EAAE;AAD2B,eAAT,CAF9B;;AAAA;AAEQC,cAAAA,QAFR;AAAA,+CAMS,KAAKC,kBAAL,CAAwBD,QAAxB,CANT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WASA,4BAAyBA,QAAzB;AAAA;AAAA;AAAA;AAAA;AAAA;AACME,cAAAA,IADN,GACa,IADb;AAAA;AAAA;AAAA,+CAGiBF,QAAQ,CAACE,IAAT,EAHjB;;AAAA;AAGIA,cAAAA,IAHJ;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAQMF,QAAQ,CAACG,EARf;AAAA;AAAA;AAAA;;AAAA,gDASWD,IATX;;AAAA;AAWUE,cAAAA,KAXV,GAWkB,IAAIC,KAAJ,CAAUL,QAAQ,CAACM,UAAnB,CAXlB;AAYIF,cAAAA,KAAK,CAACG,YAAN,GAAqB,IAArB;AACAH,cAAAA,KAAK,CAACJ,QAAN,GAAiBA,QAAjB;AACAI,cAAAA,KAAK,CAACI,YAAN,GAAqBN,IAArB;AAdJ,oBAgBUE,KAhBV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAoBA,sBAAaV,QAAb,EAAuBC,MAAvB,EAA+B;AAC7B,UAAMc,MAAM,GAAGrB,EAAE,CAACsB,SAAH,iCAAkB,KAAKjB,iBAAvB,GAA6CE,MAA7C,EAAf;AACA,UAAMgB,GAAG,GAAGxB,IAAI,CAACyB,IAAL,CAAU,KAAKpB,QAAf,EAAyBE,QAAzB,CAAZ;AACA,aAAO,CAACiB,GAAD,EAAMF,MAAN,EAAcG,IAAd,CAAmB,GAAnB,CAAP;AACD;;;;;;AAGH,eAAevB,GAAf","sourcesContent":["import path from 'path';\nimport qs from 'query-string';\n\n// Only deals with json responses\nclass Api {\n  constructor({ baseUrl, searchParams }) {\n    this._baseUrl = baseUrl;\n    this._baseSearchParams = searchParams || {};\n  }\n\n  async get(endpoint, params) {\n    const hitUrl = this._generateUrl(endpoint, params);\n    const response = await fetch(hitUrl, {\n      method: 'GET',\n    });\n\n    return this._parseJsonResponse(response);\n  }\n\n  async _parseJsonResponse(response) {\n    let json = null;\n    try {\n      json = await response.json();\n    } catch (e) {\n      // TODO Do something if response has no, or invalid JSON\n    }\n\n    if (response.ok) {\n      return json;\n    } else {\n      const error = new Error(response.statusText);\n      error.isFromServer = true;\n      error.response = response;\n      error.responseJson = json;\n\n      throw error;\n    }\n  }\n\n  _generateUrl(endpoint, params) {\n    const search = qs.stringify({ ...this._baseSearchParams, ...params });\n    const url = path.join(this._baseUrl, endpoint);\n    return [url, search].join('?');\n  }\n}\n\nexport default Api;\n"]},"metadata":{},"sourceType":"module"}